---
date created: 2022-01-22 23:32
---

## 1. 用静态工厂方法代替构造器

### 优势

- 有名称

  > 如果构造器的参数本身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读。

  // 返回素数结果
  BigInteger.probablePrime

- 不必在每次调用时创建新对象

  静态工厂方法能为**重复的**调用返回相同对象，能有助于创建**实例受控的类**。

  **实例受控的类的作用**：

  1. 确保类是 **Singleton**  （单例）
  2. 确保类是**不可实例化**的
  3. 确保**不可变的值类**不会存在两个相等的实例

  eg:

  > 当且仅当 a==b 时， a.equals(b)才为 true 这是享元模式［ Gamma95 ］的基础。

枚举（enum ）类型（ 详见第34条 ）保证了这一点。

- 可以返回原类型的任何**子类型**的对象

  应用：**API** 可以返回对象，同时不会使对象的类变为公有的。

  适用于**基于接口的框架** （ **interface-based framework** ）。 接口给静态工厂方法提供了自然返回类型。

- 返回的对象的类可以随着每次调用而发生变化

  eg:

  > EnumSet （详见第 36 条）没有公有的构造器，只有静态工厂方法 OpenJDK 实现中，

它们返回两种子类之一的一个实例，具体则取决于底层枚举类型的大小：如果它的元素有 64
个或者更少，就像大多数枚举类型一样，静态工厂方法就会返回一个 RegalarEumSet 实例，
用单个 long 进行支持；如果枚举类型有 65 个或者更多元素，工厂就返回 JumboEnumSet
实例，用一个 long 数组进行支持。

- 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在

  静态工厂方法构成了**服务提供者框架**的基础。

  **服务提供者框架**：

  多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，从实现中解耦出来。

  1. 服务接口（Serivce Interface）

     由提供者实现

  2. 提供者注册 **API** （Provider Registration API）

     提供者用来注册实现的

  3. 服务访问 **API**（Service Access API）

     客户端用来获取服务的实例

  4. 服务提供者接口（Service Provider Interface）

     表示产生服务接口实例的工厂对象

### 缺点
